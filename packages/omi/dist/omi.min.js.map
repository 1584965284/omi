{"version":3,"sources":["../src/util.js","../src/h.js","../src/vdom/index.js","../src/extend.js","../src/dom/index.js","../src/vdom/diff.js","../src/we-element.js","../src/render.js","../src/define.js","../src/clone-element.js","../src/get-host.js","../src/class.js","../node_modules/construct-style-sheets-polyfill/dist/adoptedStyleSheets.js","../src/options.js","../src/o.js","../src/omi.js"],"names":["cssToDom","css","node","document","createElement","textContent","camelCase","str","replace","$","$1","toUpperCase","Fragment","props","children","extend","obj","i","applyRef","ref","value","current","isArray","Object","prototype","toString","call","pathToArr","path","split","hyphenate","hyphenateRE","toLowerCase","capitalize","name","all","letter","s","getValByPath","forEach","prop","h","nodeName","attributes","lastSimple","child","simple","arguments","length","stack","push","pop","String","p","key","options","vnode","isSameNodeType","splitText","mapping","hydrating","_componentConstructor","isNamedNode","extend$1","handler","extension","origin","arr","get","e","type","eventProxy","el","_listeners","addEventListener","createNode","removeNode","setAccessor","component","old","isSvg","style","cssText","IS_NON_DIMENSIONAL","test","bindEvent","innerHTML","__html","pureRemoveAttribute","removeAttribute","ns","removeAttributeNS","pureSetAttribute","setAttribute","className","useCapture","event","nameLower","eventProxy$1","ret","diffLevel","isSvgMode","parent","ownerSVGElement","dom","updateSelf","innerDiffNode","ele","idiff","index","item","one","recollectNodeTree","parentNode","appendChild","out","nodeValue","createTextNode","replaceChild","vnodeName","prevProps","vchildren","firstChild","fc","a","nextSibling","constructor","is","noSlot","dangerouslySetInnerHTML","diffAttributes","min","len","childrenLen","vlen","j","keyedLen","originalChildren","keyed","vchild","_child","_component","__key","trim","isHydrating","c","f","unmountOnly","ATTR_KEY","removeChildren","oldClone","assign","receiveProps","isWeElement","attrs","ccName","indexOf","_ccName","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","HTMLElement","WeElement","_classCallCheck$1","_possibleConstructorReturn$1","define","ctor","customElements","config","Ele","_WeElement","_temp","_this","_ret","_len","args","Array","this","apply","concat","compute","propTypes","defaultProps","isLightDom","storeHelpers","func","target","cloneElement","getHost","shadowRoot","host","rpx","b","window","innerWidth","arg","classNames","classes","argType","inner","join","_Array$prototype$slic","slice","class","unshift","o","JSON","stringify","createRef","store","root","global","Math","Reflect","hasOwnProperty","BuiltInHTMLElement","construct","setPrototypeOf","Promise","resolve","then","bind","setTimeout","_HTMLElement","elementId","id","computed","isInstalled","connectedCallback","_this2","inject","provide","injection","injectKey","attrsToProps","beforeInstall","install","afterInstall","attachShadow","mode","removeChild","elementStyles","adoptedStyleSheets","styleSheet","CSSStyleSheet","replaceSync","adoptedStyleSheet","styleSheets","default","_styleSheet","beforeRender","_customStyleContent","_customStyleElement","rootNode","installed","disconnectedCallback","uninstall","update","ignoreAttrs","beforeUpdate","_willUpdate","rendered","forceUpdate","updated","_this3","updateProps","val","getAttribute","Number","Boolean","substr","Omi","parse","fire","data","CustomEvent","detail","rejectImports","contents","_contents","importPattern","console","warn","isElementConnected","element","isConnected","contains","unique","filter","diff","arr1","arr2","getShadowRoot","closedShadowRootRegistry","isCSSStyleSheetInstance","proto$1","isPrototypeOf","nonConstructedProto","isNonConstructedStyleSheetInstance","addAdopterLocation","sheet","location","adopter","$adoptersByLocation","set","$locations","getAdopterByLocation","removeAdopterLocation","delete","_location","restyleAdopter","requestAnimationFrame","$basicStyleElement","$appliedMethods","command","method","checkInvocationCorrectness","has","ConstructedStyleSheet","bootstrapper","body","WeakMap","getAssociatedLocation","locations","Location","attachAdoptedStyleSheetProperty","defineProperty","configurable","enumerable","sheets","traverseWebComponents","callback","iter","createNodeIterator","NodeFilter","SHOW_ELEMENT","foundNode","FILTER_ACCEPT","FILTER_REJECT","next","nextNode","isExistingAdopter","HTMLStyleElement","$uniqueSheets","some","getAdopterContainer","$element","Document","adopt","styleList","createDocumentFragment","observer","$observer","container","disconnect","insertBefore","observe","defaultObserverOptions","MutationObserver","mutations","mutation","hasShadyCss","addedNodes","Element","connect","removedNodes","ShadyCSS","nativeShadow","implementation","createHTMLDocument","cssStyleSheetMethods","NonConstructedStyleSheet","reject","_DOMException","self_1","cssRules","basicSheet","Symbol","hasInstance","childList","subtree","readyState","locationType","every","oldUniqueSheets","uniqueSheets","proto","attach_1","init","documentLocation","Component","defineElement","tag","elements","render","extractClass","omi","unbind","version","module","exports"],"mappings":"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","file":"omi.min.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This shim allows elements written in, or compiled to, ES5 to work on native\n * implementations of Custom Elements v1. It sets new.target to the value of\n * this.constructor so that the native HTMLElement constructor can access the\n * current under-construction element's definition.\n */\n;(function() {\n  if (\n    // No Reflect, no classes, no need for shim because native custom elements\n    // require ES2015 classes or Reflect.\n    window.Reflect === undefined ||\n    window.customElements === undefined ||\n    // The webcomponentsjs custom elements polyfill doesn't require\n    // ES2015-compatible construction (`super()` or `Reflect.construct`).\n    window.customElements.hasOwnProperty('polyfillWrapFlushCallback')\n  ) {\n    return\n  }\n  const BuiltInHTMLElement = HTMLElement\n  window.HTMLElement = function HTMLElement() {\n    return Reflect.construct(BuiltInHTMLElement, [], this.constructor)\n  }\n  HTMLElement.prototype = BuiltInHTMLElement.prototype\n  HTMLElement.prototype.constructor = HTMLElement\n  Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement)\n})()\n\nexport function cssToDom(css) {\n  const node = document.createElement('style')\n  node.textContent = css\n  return node\n}\n\nexport function camelCase(str) {\n  return str.replace(/-(\\w)/g, ($, $1) => {\n    return $1.toUpperCase()\n  })\n}\n\nexport function Fragment(props) {\n  return props.children\n}\n\nexport function extend(obj, props) {\n  for (let i in props) obj[i] = props[i]\n  return obj\n}\n\n/** Invoke or update a ref, depending on whether it is a function or object ref.\n *  @param {object|function} [ref=null]\n *  @param {any} [value]\n */\nexport function applyRef(ref, value) {\n  if (ref != null) {\n    if (typeof ref == 'function') ref(value)\n    else ref.current = value\n  }\n}\n\n/**\n * Call a function asynchronously, as soon as possible. Makes\n * use of HTML Promise to schedule the callback if available,\n * otherwise falling back to `setTimeout` (mainly for IE<11).\n * @type {(callback: function) => void}\n */\nexport const defer =\n  typeof Promise == 'function'\n    ? Promise.resolve().then.bind(Promise.resolve())\n    : setTimeout\n\nexport function isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]'\n}\n\nexport function pathToArr(path) {\n  if (typeof path !== 'string' || !path) return []\n  // return path.split(/\\.|\\[|\\]/).filter(name => !!name)\n  return path\n    .replace(/]/g, '')\n    .replace(/\\[/g, '.')\n    .split('.')\n}\n\nconst hyphenateRE = /\\B([A-Z])/g\nexport function hyphenate(str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n}\n\nexport function capitalize(name) {\n  return name\n    .replace(/\\-(\\w)/g, function(all, letter) {\n      return letter.toUpperCase()\n    })\n    .replace(/^\\S/, s => s.toUpperCase())\n}\n\nexport function getValByPath(path, current) {\n  const arr = pathToArr(path)\n  arr.forEach(prop => {\n    current = current[prop]\n  })\n  return current\n}\n\nexport function removeItem(item, arr) {\n  if (!arr) return\n  for (let i = 0, len = arr.length; i < len; i++) {\n    if (arr[i] === item) {\n      arr.splice(i, 1)\n      break\n    }\n  }\n}\n","import options from './options'\nimport { Fragment } from './util'\n\nconst stack = []\n\nexport function h(nodeName, attributes) {\n  let children = [],\n    lastSimple,\n    child,\n    simple,\n    i\n  for (i = arguments.length; i-- > 2; ) {\n    stack.push(arguments[i])\n  }\n  if (attributes && attributes.children != null) {\n    if (!stack.length) stack.push(attributes.children)\n    delete attributes.children\n  }\n  while (stack.length) {\n    if ((child = stack.pop()) && child.pop !== undefined) {\n      for (i = child.length; i--; ) stack.push(child[i])\n    } else {\n      if (typeof child === 'boolean') child = null\n\n      if ((simple = typeof nodeName !== 'function')) {\n        if (child == null) child = ''\n        else if (typeof child === 'number') child = String(child)\n        else if (typeof child !== 'string') simple = false\n      }\n\n      if (simple && lastSimple) {\n        children[children.length - 1] += child\n      } else if (children.length === 0) {\n        children = [child]\n      } else {\n        children.push(child)\n      }\n\n      lastSimple = simple\n    }\n  }\n\n  if (nodeName === Fragment) {\n    return children\n  }\n\n  const p = {\n    nodeName,\n    children,\n    attributes: attributes == null ? undefined : attributes,\n    key: attributes == null ? undefined : attributes.key\n  }\n\n  // if a \"vnode hook\" is defined, pass every created VNode to it\n  if (options.vnode !== undefined) options.vnode(p)\n\n  return p\n}\n","import { extend } from '../util'\nimport options from '../options'\n/**\n * Check if two nodes are equivalent.\n *\n * @param {Node} node      DOM Node to compare\n * @param {VNode} vnode      Virtual DOM node to compare\n * @param {boolean} [hydrating=false]  If true, ignores component constructors when comparing.\n * @private\n */\nexport function isSameNodeType(node, vnode, hydrating) {\n  if (typeof vnode === 'string' || typeof vnode === 'number') {\n    return node.splitText !== undefined\n  }\n  if (typeof vnode.nodeName === 'string') {\n    return !node._componentConstructor && isNamedNode(node, vnode.nodeName)\n  } else if (typeof vnode.nodeName === 'function') {\n    return options.mapping[node.nodeName.toLowerCase()] === vnode.nodeName\n  }\n  return hydrating || node._componentConstructor === vnode.nodeName\n}\n\n/**\n * Check if an Element has a given nodeName, case-insensitively.\n *\n * @param {Element} node  A DOM Element to inspect the name of.\n * @param {String} nodeName  Unnormalized name to compare against.\n */\nexport function isNamedNode(node, nodeName) {\n  return (\n    node.normalizedNodeName === nodeName ||\n    node.nodeName.toLowerCase() === nodeName.toLowerCase()\n  )\n}\n\n/**\n * Reconstruct Component-style `props` from a VNode.\n * Ensures default/fallback values from `defaultProps`:\n * Own-properties of `defaultProps` not present in `vnode.attributes` are added.\n *\n * @param {VNode} vnode\n * @returns {Object} props\n */\nexport function getNodeProps(vnode) {\n  let props = extend({}, vnode.attributes)\n  props.children = vnode.children\n\n  let defaultProps = vnode.nodeName.defaultProps\n  if (defaultProps !== undefined) {\n    for (let i in defaultProps) {\n      if (props[i] === undefined) {\n        props[i] = defaultProps[i]\n      }\n    }\n  }\n\n  return props\n}\n","import { pathToArr } from './util'\n\nexport const extension = {}\n\nexport function extend(name, handler) {\n  extension['o-' + name] = handler\n}\n\nexport function set(origin, path, value) {\n  const arr = pathToArr(path)\n  let current = origin\n  for (let i = 0, len = arr.length; i < len; i++) {\n    if (i === len - 1) {\n      current[arr[i]] = value\n    } else {\n      current = current[arr[i]]\n    }\n  }\n}\n\nexport function get(origin, path) {\n  const arr = pathToArr(path)\n  let current = origin\n  for (let i = 0, len = arr.length; i < len; i++) {\n    current = current[arr[i]]\n  }\n\n  return current\n}\n\nfunction eventProxy(e) {\n  return this._listeners[e.type](e)\n}\n\nexport function bind(el, type, handler) {\n  el._listeners = el._listeners || {}\n  el._listeners[type] = handler\n  el.addEventListener(type, eventProxy)\n}\n\nexport function unbind(el, type) {\n  el.removeEventListener(type, eventProxy)\n}\n","import { IS_NON_DIMENSIONAL } from '../constants'\nimport { applyRef } from '../util'\nimport options from '../options'\nimport { extension } from '../extend'\n\n/**\n * Create an element with the given nodeName.\n * @param {string} nodeName The DOM node to create\n * @param {boolean} [isSvg=false] If `true`, creates an element within the SVG\n *  namespace.\n * @returns {Element} The created DOM node\n */\nexport function createNode(nodeName, isSvg) {\n  /** @type {Element} */\n  let node = isSvg\n    ? document.createElementNS('http://www.w3.org/2000/svg', nodeName)\n    : document.createElement(nodeName)\n  node.normalizedNodeName = nodeName\n  return node\n}\n\n/**\n * Remove a child node from its parent if attached.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n  let parentNode = node.parentNode\n  if (parentNode) parentNode.removeChild(node)\n}\n\n/**\n * Set a named attribute on the given Node, with special behavior for some names\n * and event handlers. If `value` is `null`, the attribute/handler will be\n * removed.\n * @param {Element} node An element to mutate\n * @param {string} name The name/key to set, such as an event or attribute name\n * @param {*} old The last value that was set for this name/node pair\n * @param {*} value An attribute value, such as a function to be used as an\n *  event handler\n * @param {boolean} isSvg Are we currently diffing inside an svg?\n * @private\n */\nexport function setAccessor(node, name, old, value, isSvg, component) {\n  if (name === 'className') name = 'class'\n\n  if (name[0] == 'o' && name[1] == '-') {\n    if (extension[name]) {\n      extension[name](node, value, component)\n    }\n  } else if (name === 'key') {\n    // ignore\n  } else if (name === 'ref') {\n    applyRef(old, null)\n    applyRef(value, node)\n  } else if (name === 'class' && !isSvg) {\n    node.className = value || ''\n  } else if (name === 'style') {\n    if (!value || typeof value === 'string' || typeof old === 'string') {\n      node.style.cssText = value || ''\n    }\n    if (value && typeof value === 'object') {\n      if (typeof old !== 'string') {\n        for (let i in old) if (!(i in value)) node.style[i] = ''\n      }\n      for (let i in value) {\n        node.style[i] =\n          typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false\n            ? value[i] + 'px'\n            : value[i]\n      }\n    }\n  } else if (name === 'dangerouslySetInnerHTML') {\n    if (value) node.innerHTML = value.__html || ''\n  } else if (name[0] == 'o' && name[1] == 'n') {\n    bindEvent(node, name, value, old)\n  } else if (node.nodeName === 'INPUT' && name === 'value') {\n    node[name] = value == null ? '' : value\n  } else if (\n    name !== 'list' &&\n    name !== 'type' &&\n    name !== 'css' &&\n    !isSvg &&\n    name in node &&\n    value !== ''\n  ) {\n    //value !== '' fix for selected, disabled, checked with pure element\n    // Attempt to set a DOM property to the given value.\n    // IE & FF throw for certain property-value combinations.\n    try {\n      node[name] = value == null ? '' : value\n    } catch (e) {}\n    if ((value == null || value === false) && name != 'spellcheck')\n      node.pureRemoveAttribute\n        ? node.pureRemoveAttribute(name)\n        : node.removeAttribute(name)\n  } else {\n    let ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''))\n    // spellcheck is treated differently than all other boolean values and\n    // should not be removed when the value is `false`. See:\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-spellcheck\n    if (value == null || value === false) {\n      if (ns)\n        node.removeAttributeNS(\n          'http://www.w3.org/1999/xlink',\n          name.toLowerCase()\n        )\n      else\n        node.pureRemoveAttribute\n          ? node.pureRemoveAttribute(name)\n          : node.removeAttribute(name)\n    } else if (typeof value !== 'function') {\n      if (ns) {\n        node.setAttributeNS(\n          'http://www.w3.org/1999/xlink',\n          name.toLowerCase(),\n          value\n        )\n      } else {\n        node.pureSetAttribute\n          ? node.pureSetAttribute(name, value)\n          : node.setAttribute(name, value)\n      }\n    }\n  }\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n  return this._listeners[e.type]((options.event && options.event(e)) || e)\n}\n\nfunction bindEvent(node, name, value, old) {\n  let useCapture = name !== (name = name.replace(/Capture$/, ''))\n  let nameLower = name.toLowerCase()\n  name = (nameLower in node ? nameLower : name).slice(2)\n  if (value) {\n    if (!old) {\n      node.addEventListener(name, eventProxy, useCapture)\n    }\n  } else {\n    node.removeEventListener(name, eventProxy, useCapture)\n  }\n  ;(node._listeners || (node._listeners = {}))[name] = value\n}\n","import { ATTR_KEY } from '../constants'\nimport { isSameNodeType, isNamedNode } from './index'\nimport { createNode, setAccessor } from '../dom/index'\nimport { camelCase, isArray, Fragment } from '../util'\nimport { removeNode } from '../dom/index'\nimport options from '../options'\n\n/** Queue of components that have been mounted and are awaiting componentDidMount */\nexport const mounts = []\n\n/** Diff recursion count, used to track the end of the diff cycle. */\nexport let diffLevel = 0\n\n/** Global flag indicating if the diff is currently within an SVG */\nlet isSvgMode = false\n\n/** Global flag indicating if the diff is performing hydration */\nlet hydrating = false\n\n/** Apply differences in a given vnode (and it's deep children) to a real DOM Node.\n *  @param {Element} [dom=null]    A DOM node to mutate into the shape of the `vnode`\n *  @param {VNode} vnode      A VNode (with descendants forming a tree) representing the desired DOM structure\n *  @returns {Element} dom      The created/mutated element\n *  @private\n */\nexport function diff(dom, vnode, parent, component, updateSelf) {\n  // first render return undefined\n  if (!dom && !vnode) return\n  // diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)\n  let ret\n  if (!diffLevel++) {\n    // when first starting the diff, check if we're diffing an SVG or within an SVG\n    isSvgMode = parent != null && parent.ownerSVGElement !== undefined\n\n    // hydration is indicated by the existing element to be diffed not having a prop cache\n    hydrating = dom != null && !(ATTR_KEY in dom)\n  }\n  if (vnode && vnode.nodeName === Fragment) {\n    vnode = vnode.children\n  }\n  if (isArray(vnode)) {\n    if (parent) {\n      // don't use css and props.css when using h.f\n      // diff node list and vnode list\n      innerDiffNode(parent, vnode, hydrating, component, updateSelf)\n    } else {\n      // connectedCallback 的时候 parent 为 null\n      ret = []\n      vnode.forEach((item, index) => {\n        let ele = idiff(index === 0 ? dom : null, item, component, updateSelf)\n        // 返回数组的情况下，在 WeElement 中进行了 shadowRoot.appendChild\n        // 所有不会出现 vnode index 大于 0 丢失的情况\n        ret.push(ele)\n      })\n    }\n  } else {\n    if (isArray(dom)) {\n      dom.forEach((one, index) => {\n        if (index === 0) {\n          ret = idiff(one, vnode, component, updateSelf)\n        } else {\n          recollectNodeTree(one, false)\n        }\n      })\n    } else {\n      ret = idiff(dom, vnode, component, updateSelf)\n    }\n    // append the element if its a new parent\n    if (parent && ret.parentNode !== parent) parent.appendChild(ret)\n  }\n\n  // diffLevel being reduced to 0 means we're exiting the diff\n  if (!--diffLevel) {\n    hydrating = false\n    // invoke queued componentDidMount lifecycle methods\n  }\n\n  return ret\n}\n\n/** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */\nfunction idiff(dom, vnode, component, updateSelf) {\n  if (dom && vnode && dom.props) {\n    dom.props.children = vnode.children\n  }\n  let out = dom,\n    prevSvgMode = isSvgMode\n\n  // empty values (null, undefined, booleans) render as empty Text nodes\n  if (vnode == null || typeof vnode === 'boolean') vnode = ''\n\n  // Fast case: Strings & Numbers create/update Text nodes.\n  if (typeof vnode === 'string' || typeof vnode === 'number') {\n    // update if it's already a Text node:\n    if (\n      dom &&\n      dom.splitText !== undefined &&\n      dom.parentNode &&\n      (!dom._component || component)\n    ) {\n      /* istanbul ignore if */ /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */\n      if (dom.nodeValue != vnode) {\n        dom.nodeValue = vnode\n      }\n    } else {\n      // it wasn't a Text node: replace it with one and recycle the old Element\n      out = document.createTextNode(vnode)\n      if (dom) {\n        if (dom.parentNode) dom.parentNode.replaceChild(out, dom)\n        recollectNodeTree(dom, true)\n      }\n    }\n\n    out[ATTR_KEY] = true\n\n    return out\n  }\n\n  // If the VNode represents a Component, perform a component diff:\n  let vnodeName = vnode.nodeName\n  if (typeof vnodeName === 'function') {\n    for (let key in options.mapping) {\n      if (options.mapping[key] === vnodeName) {\n        vnodeName = key\n        vnode.nodeName = key\n        break\n      }\n    }\n  }\n  // Tracks entering and exiting SVG namespace when descending through the tree.\n  isSvgMode =\n    vnodeName === 'svg'\n      ? true\n      : vnodeName === 'foreignObject'\n      ? false\n      : isSvgMode\n\n  // If there's no existing element or it's the wrong type, create a new one:\n  vnodeName = String(vnodeName)\n  if (!dom || !isNamedNode(dom, vnodeName)) {\n    out = createNode(vnodeName, isSvgMode)\n\n    if (dom) {\n      // move children into the replacement node\n      while (dom.firstChild) out.appendChild(dom.firstChild)\n\n      // if the previous Element was mounted into the DOM, replace it inline\n      if (dom.parentNode) dom.parentNode.replaceChild(out, dom)\n\n      // recycle the old element (skips non-Element node types)\n      recollectNodeTree(dom, true)\n    }\n  }\n\n  let fc = out.firstChild,\n    props = out[ATTR_KEY],\n    vchildren = vnode.children\n\n  if (props == null) {\n    props = out[ATTR_KEY] = {}\n    for (let a = out.attributes, i = a.length; i--; )\n      props[a[i].name] = a[i].value\n  }\n\n  // Optimization: fast-path for elements containing a single TextNode:\n  if (\n    !hydrating &&\n    vchildren &&\n    vchildren.length === 1 &&\n    typeof vchildren[0] === 'string' &&\n    fc != null &&\n    fc.splitText !== undefined &&\n    fc.nextSibling == null\n  ) {\n    if (fc.nodeValue != vchildren[0]) {\n      fc.nodeValue = vchildren[0]\n    }\n  }\n  // otherwise, if there are existing or new children, diff them:\n  else if ((vchildren && vchildren.length) || fc != null) {\n    if (!(out.constructor.is == 'WeElement' && out.constructor.noSlot)) {\n      innerDiffNode(\n        out,\n        vchildren,\n        hydrating || props.dangerouslySetInnerHTML != null,\n        component,\n        updateSelf\n      )\n    }\n  }\n\n  // Apply attributes/props from VNode to the DOM Element:\n  diffAttributes(out, vnode.attributes, props, component, updateSelf)\n  if (out.props) {\n    out.props.children = vnode.children\n  }\n  // restore previous SVG mode: (in case we're exiting an SVG namespace)\n  isSvgMode = prevSvgMode\n\n  return out\n}\n\n/** Apply child and attribute changes between a VNode and a DOM Node to the DOM.\n *  @param {Element} dom      Element whose children should be compared & mutated\n *  @param {Array} vchildren    Array of VNodes to compare to `dom.childNodes`\n *  @param {Boolean} isHydrating  If `true`, consumes externally created elements similar to hydration\n */\nfunction innerDiffNode(dom, vchildren, isHydrating, component, updateSelf) {\n  let originalChildren = dom.childNodes,\n    children = [],\n    keyed = {},\n    keyedLen = 0,\n    min = 0,\n    len = originalChildren.length,\n    childrenLen = 0,\n    vlen = vchildren ? vchildren.length : 0,\n    j,\n    c,\n    f,\n    vchild,\n    child\n\n  // Build up a map of keyed children and an Array of unkeyed children:\n  if (len !== 0) {\n    for (let i = 0; i < len; i++) {\n      let child = originalChildren[i],\n        props = child[ATTR_KEY],\n        key =\n          vlen && props\n            ? child._component\n              ? child._component.__key\n              : props.key\n            : null\n      if (key != null) {\n        keyedLen++\n        keyed[key] = child\n      } else if (\n        props ||\n        (child.splitText !== undefined\n          ? isHydrating\n            ? child.nodeValue.trim()\n            : true\n          : isHydrating)\n      ) {\n        children[childrenLen++] = child\n      }\n    }\n  }\n\n  if (vlen !== 0) {\n    for (let i = 0; i < vlen; i++) {\n      vchild = vchildren[i]\n      child = null\n\n      if (vchild) {\n        // attempt to find a node based on key matching\n        let key = vchild.key\n        if (key != null) {\n          if (keyedLen && keyed[key] !== undefined) {\n            child = keyed[key]\n            keyed[key] = undefined\n            keyedLen--\n          }\n        }\n        // attempt to pluck a node of the same type from the existing children\n        else if (!child && min < childrenLen) {\n          for (j = min; j < childrenLen; j++) {\n            if (\n              children[j] !== undefined &&\n              isSameNodeType((c = children[j]), vchild, isHydrating)\n            ) {\n              child = c\n              children[j] = undefined\n              if (j === childrenLen - 1) childrenLen--\n              if (j === min) min++\n              break\n            }\n          }\n        }\n      }\n\n      // morph the matched/found/created DOM child to match vchild (deep)\n      child = idiff(child, vchild, component, updateSelf)\n\n      f = originalChildren[i]\n      if (child && child !== dom && child !== f) {\n        if (f == null) {\n          dom.appendChild(child)\n        } else if (child === f.nextSibling) {\n          removeNode(f)\n        } else {\n          dom.insertBefore(child, f)\n        }\n      }\n    }\n  }\n\n  // remove unused keyed children:\n  if (keyedLen) {\n    for (let i in keyed)\n      if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false)\n  }\n\n  // remove orphaned unkeyed children:\n  while (min <= childrenLen) {\n    if ((child = children[childrenLen--]) !== undefined)\n      recollectNodeTree(child, false)\n  }\n}\n\n/** Recursively recycle (or just unmount) a node and its descendants.\n *  @param {Node} node            DOM node to start unmount/removal from\n *  @param {Boolean} [unmountOnly=false]  If `true`, only triggers unmount lifecycle, skips removal\n */\nexport function recollectNodeTree(node, unmountOnly) {\n  // If the node's VNode had a ref function, invoke it with null here.\n  // (this is part of the React spec, and smart for unsetting references)\n  if (node[ATTR_KEY] != null && node[ATTR_KEY].ref) {\n    if (typeof node[ATTR_KEY].ref === 'function') {\n      node[ATTR_KEY].ref(null)\n    } else if (node[ATTR_KEY].ref.current) {\n      node[ATTR_KEY].ref.current = null\n    }\n  }\n\n  if (unmountOnly === false || node[ATTR_KEY] == null) {\n    removeNode(node)\n  }\n\n  removeChildren(node)\n}\n\n/** Recollect/unmount all children.\n *  - we use .lastChild here because it causes less reflow than .firstChild\n *  - it's also cheaper than accessing the .childNodes Live NodeList\n */\nexport function removeChildren(node) {\n  node = node.lastChild\n  while (node) {\n    let next = node.previousSibling\n    recollectNodeTree(node, true)\n    node = next\n  }\n}\n\n/** Apply differences in attributes from a VNode to the given DOM Element.\n *  @param {Element} dom    Element with attributes to diff `attrs` against\n *  @param {Object} attrs    The desired end-state key-value attribute pairs\n *  @param {Object} old      Current/previous attributes (from previous VNode or element's prop cache)\n */\nfunction diffAttributes(dom, attrs, old, component, updateSelf) {\n  let name\n  //let update = false\n  let isWeElement = dom.update\n  let oldClone\n  if (dom.receiveProps) {\n    oldClone = Object.assign({}, old)\n  }\n  // remove attributes no longer present on the vnode by setting them to undefined\n  for (name in old) {\n    if (!(attrs && attrs[name] != null) && old[name] != null) {\n      setAccessor(\n        dom,\n        name,\n        old[name],\n        (old[name] = undefined),\n        isSvgMode,\n        component\n      )\n      if (isWeElement) {\n        delete dom.props[name]\n        //update = true\n      }\n    }\n  }\n\n  // add new & update changed attributes\n  for (name in attrs) {\n    if (isWeElement && typeof attrs[name] === 'object' && name !== 'ref') {\n      if (name === 'style') {\n        setAccessor(\n          dom,\n          name,\n          old[name],\n          (old[name] = attrs[name]),\n          isSvgMode,\n          component\n        )\n      }\n      let ccName = camelCase(name)\n      dom.props[ccName] = old[ccName] = attrs[name]\n      //update = true\n    } else if (\n      name !== 'children' &&\n      (!(name in old) ||\n        attrs[name] !==\n          (name === 'value' || name === 'checked' ? dom[name] : old[name]))\n    ) {\n      setAccessor(dom, name, old[name], attrs[name], isSvgMode, component)\n      //fix lazy load props missing\n      if (dom.nodeName.indexOf('-') !== -1) {\n        dom.props = dom.props || {}\n        let ccName = camelCase(name)\n        dom.props[ccName] = old[ccName] = attrs[name]\n        //update = true\n      } else {\n        old[name] = attrs[name]\n      }\n    }\n  }\n\n  if (isWeElement && !updateSelf && dom.parentNode) {\n    //__hasChildren is not accuracy when it was empty at first, so add dom.children.length > 0 condition\n    //if (update || dom.__hasChildren || dom.children.length > 0 || (dom.store && !dom.store.data)) {\n    if (dom.receiveProps(dom.props, oldClone) !== false) {\n      dom.update()\n    }\n    //}\n  }\n}\n","import { cssToDom, isArray, hyphenate, getValByPath, capitalize } from './util'\nimport { diff } from './vdom/diff'\nimport options from './options'\n\nlet id = 0\n\nexport default class WeElement extends HTMLElement {\n  static is = 'WeElement'\n\n  constructor() {\n    super()\n    // fix lazy load props missing\n    this.props = Object.assign({}, this.constructor.defaultProps, this.props)\n    this.elementId = id++\n    this.computed = {}\n    this.isInstalled = false\n  }\n\n  connectedCallback() {\n    let p = this.parentNode\n    while (p && !this.store) {\n      this.store = p.store\n      p = p.parentNode || p.host\n    }\n\n    if (this.inject) {\n      this.injection = {}\n      p = this.parentNode\n      let provide\n      while (p && !provide) {\n        provide = p.provide\n        p = p.parentNode || p.host\n      }\n      if (provide) {\n        this.inject.forEach(injectKey => {\n          this.injection[injectKey] = provide[injectKey]\n        })\n      } else {\n        throw 'The provide prop was not found on the parent node or the provide type is incorrect.'\n      }\n    }\n\n    this.attrsToProps()\n\n    this.beforeInstall()\n    this.install()\n    this.afterInstall()\n\n    let shadowRoot\n    if (this.constructor.isLightDom) {\n      shadowRoot = this\n    } else {\n      if (!this.shadowRoot) {\n        shadowRoot = this.attachShadow({\n          mode: 'open'\n        })\n      } else {\n        shadowRoot = this.shadowRoot\n        let fc\n        while ((fc = shadowRoot.firstChild)) {\n          shadowRoot.removeChild(fc)\n        }\n      }\n    }\n\n    if (this.constructor.elementStyles) {\n      shadowRoot.adoptedStyleSheets = this.constructor.elementStyles\n    } else {\n      const css = this.constructor.css\n      if (css) {\n        if (typeof css === 'string') {\n          const styleSheet = new CSSStyleSheet()\n          styleSheet.replaceSync(css)\n          shadowRoot.adoptedStyleSheets = [styleSheet]\n        } else if (Object.prototype.toString.call(css) === '[object Array]') {\n          const styleSheets = []\n          css.forEach(styleSheet => {\n            if (typeof styleSheet === 'string') {\n              const adoptedStyleSheet = new CSSStyleSheet()\n              adoptedStyleSheet.replaceSync(styleSheet)\n              styleSheets.push(adoptedStyleSheet)\n            } else {\n              styleSheets.push(styleSheet)\n            }\n            shadowRoot.adoptedStyleSheets = styleSheets\n          })\n        } else if (css.default && typeof css.default === 'string') {\n          // [object Module]\n          const styleSheet = new CSSStyleSheet()\n          styleSheet.replaceSync(css.default)\n          shadowRoot.adoptedStyleSheets = [styleSheet]\n        } else {\n          shadowRoot.adoptedStyleSheets = [css]\n        }\n        this.constructor.elementStyles = shadowRoot.adoptedStyleSheets\n      }\n    }\n\n    this.beforeRender()\n    options.afterInstall && options.afterInstall(this)\n\n    const rendered = this.render(this.props, this.store)\n\n    this.rootNode = diff(null, rendered, null, this)\n    this.rendered()\n\n    if (this.css) {\n      shadowRoot.appendChild(\n        cssToDom(typeof this.css === 'function' ? this.css() : this.css)\n      )\n    }\n\n    if (this.props.css) {\n      this._customStyleElement = cssToDom(this.props.css)\n      this._customStyleContent = this.props.css\n      shadowRoot.appendChild(this._customStyleElement)\n    }\n\n    if (isArray(this.rootNode)) {\n      this.rootNode.forEach(function(item) {\n        shadowRoot.appendChild(item)\n      })\n    } else {\n      this.rootNode && shadowRoot.appendChild(this.rootNode)\n    }\n    this.installed()\n    this.isInstalled = true\n  }\n\n  disconnectedCallback() {\n    this.uninstall()\n    this.isInstalled = false\n  }\n\n  update(ignoreAttrs, updateSelf) {\n    this._willUpdate = true\n    this.beforeUpdate()\n    this.beforeRender()\n    //fix null !== undefined\n    if (this._customStyleContent != this.props.css) {\n      this._customStyleContent = this.props.css\n      this._customStyleElement.textContent = this._customStyleContent\n    }\n    this.attrsToProps(ignoreAttrs)\n\n    const rendered = this.render(this.props, this.store)\n    this.rendered()\n\n    this.rootNode = diff(\n      this.rootNode,\n      rendered,\n      this.constructor.isLightDom ? this : this.shadowRoot,\n      this,\n      updateSelf\n    )\n    this._willUpdate = false\n    this.updated()\n  }\n\n  forceUpdate() {\n    this.update(true)\n  }\n\n  updateProps(obj) {\n    Object.keys(obj).forEach(key => {\n      this.props[key] = obj[key]\n      if (this.prevProps) {\n        this.prevProps[key] = obj[key]\n      }\n    })\n    this.forceUpdate()\n  }\n\n  updateSelf(ignoreAttrs) {\n    this.update(ignoreAttrs, true)\n  }\n\n  removeAttribute(key) {\n    super.removeAttribute(key)\n    //Avoid executing removeAttribute methods before connectedCallback\n    this.isInstalled && this.update()\n  }\n\n  setAttribute(key, val) {\n    if (val && typeof val === 'object') {\n      super.setAttribute(key, JSON.stringify(val))\n    } else {\n      super.setAttribute(key, val)\n    }\n    //Avoid executing setAttribute methods before connectedCallback\n    this.isInstalled && this.update()\n  }\n\n  pureRemoveAttribute(key) {\n    super.removeAttribute(key)\n  }\n\n  pureSetAttribute(key, val) {\n    super.setAttribute(key, val)\n  }\n\n  attrsToProps(ignoreAttrs) {\n    if (\n      ignoreAttrs ||\n      (this.store && this.store.ignoreAttrs) ||\n      this.props.ignoreAttrs\n    )\n      return\n    const ele = this\n    ele.props['css'] = ele.getAttribute('css')\n    const attrs = this.constructor.propTypes\n    if (!attrs) return\n    Object.keys(attrs).forEach(key => {\n      const type = attrs[key]\n      const val = ele.getAttribute(hyphenate(key))\n      if (val !== null) {\n        switch (type) {\n          case String:\n            ele.props[key] = val\n            break\n          case Number:\n            ele.props[key] = Number(val)\n            break\n          case Boolean:\n            if (val === 'false' || val === '0') {\n              ele.props[key] = false\n            } else {\n              ele.props[key] = true\n            }\n            break\n          case Array:\n          case Object:\n            if (val[0] === ':') {\n              ele.props[key] = getValByPath(val.substr(1), Omi.$)\n            } else {\n              ele.props[key] = JSON.parse(\n                val\n                  .replace(/(['\"])?([a-zA-Z0-9_-]+)(['\"])?:([^\\/])/g, '\"$2\":$4')\n                  .replace(/'([\\s\\S]*?)'/g, '\"$1\"')\n                  .replace(/,(\\s*})/g, '$1')\n              )\n            }\n            break\n        }\n      } else {\n        if (\n          ele.constructor.defaultProps &&\n          ele.constructor.defaultProps.hasOwnProperty(key)\n        ) {\n          ele.props[key] = ele.constructor.defaultProps[key]\n        } else {\n          ele.props[key] = null\n        }\n      }\n    })\n  }\n\n  fire(name, data) {\n    const handler = this.props[`on${capitalize(name)}`]\n    if (handler) {\n      handler(\n        new CustomEvent(name, {\n          detail: data\n        })\n      )\n    } else {\n      this.dispatchEvent(\n        new CustomEvent(name, {\n          detail: data\n        })\n      )\n    }\n  }\n\n  beforeInstall() {}\n\n  install() {}\n\n  afterInstall() {}\n\n  installed() {}\n\n  uninstall() {}\n\n  beforeUpdate() {}\n\n  updated() {}\n\n  beforeRender() {}\n\n  rendered() {}\n\n  receiveProps() {}\n}\n","import { diff } from './vdom/diff'\n\nexport function render(vnode, parent, store) {\n  parent = typeof parent === 'string' ? document.querySelector(parent) : parent\n  if (store) {\n    parent.store = store\n  }\n  return diff(null, vnode, parent, false)\n}\n","import WeElement from './we-element'\nimport options from './options'\n\nconst storeHelpers = ['use', 'useSelf']\n\nexport function define(name, ctor, config) {\n  if (customElements.get(name)) {\n    return\n  }\n  if (options.mapping[name]) {\n    return\n  }\n  if (ctor.is === 'WeElement') {\n    customElements.define(name, ctor)\n    options.mapping[name] = ctor\n  } else {\n    if (typeof config === 'string') {\n      config = { css: config }\n    } else {\n      config = config || {}\n    }\n\n    class Ele extends WeElement {\n      static css = config.css\n\n      static propTypes = config.propTypes\n\n      static defaultProps = config.defaultProps\n\n      static isLightDom = config.isLightDom\n\n      compute = config.compute\n\n      render() {\n        return ctor.call(this, this)\n      }\n    }\n\n    for (let key in config) {\n      if (typeof config[key] === 'function') {\n        Ele.prototype[key] = function() {\n          return config[key].apply(this, arguments)\n        }\n      }\n    }\n\n    storeHelpers.forEach(func => {\n      if (config[func] && config[func] !== 'function') {\n        Ele.prototype[func] = function() {\n          return config[func]\n        }\n      }\n    })\n\n    customElements.define(name, Ele)\n    options.mapping[name] = Ele\n  }\n}\n","import { extend } from './util'\nimport { h } from './h'\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {VNode} vnode    The virtual DOM element to clone\n * @param {Object} props  Attributes/props to add when cloning\n * @param {VNode} rest    Any additional arguments will be used as replacement children.\n */\nexport function cloneElement(vnode, props) {\n  return h(\n    vnode.nodeName,\n    extend(extend({}, vnode.attributes), props),\n    arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children\n  )\n}\n","export function getHost(ele) {\n  let p = ele.parentNode\n  while (p) {\n    if (p.host) {\n      return p.host\n    } else if (p.shadowRoot && p.shadowRoot.host) {\n      return p.shadowRoot.host\n    } else {\n      p = p.parentNode\n    }\n  }\n}\n","/**\n * classNames based on https://github.com/JedWatson/classnames\n * by Jed Watson\n * Licensed under the MIT License\n * https://github.com/JedWatson/classnames/blob/master/LICENSE\n * modified by dntzhang\n */\n\nvar hasOwn = {}.hasOwnProperty\n\nexport function classNames() {\n  var classes = []\n\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i]\n    if (!arg) continue\n\n    var argType = typeof arg\n\n    if (argType === 'string' || argType === 'number') {\n      classes.push(arg)\n    } else if (Array.isArray(arg) && arg.length) {\n      var inner = classNames.apply(null, arg)\n      if (inner) {\n        classes.push(inner)\n      }\n    } else if (argType === 'object') {\n      for (var key in arg) {\n        if (hasOwn.call(arg, key) && arg[key]) {\n          classes.push(key)\n        }\n      }\n    }\n  }\n\n  return classes.join(' ')\n}\n\nexport function extractClass() {\n  const [props, ...args] = Array.prototype.slice.call(arguments, 0)\n  if (props.class) {\n    args.unshift(props.class)\n    delete props.class\n  } else if (props.className) {\n    args.unshift(props.className)\n    delete props.className\n  }\n  if (args.length > 0) {\n    return { class: classNames.apply(null, args) }\n  }\n}\n","(function () {\n    'use strict';\n\n    if (typeof document === 'undefined' || 'adoptedStyleSheets' in document) { return; }\n\n    var hasShadyCss = 'ShadyCSS' in window && !ShadyCSS.nativeShadow;\n    var bootstrapper = document.implementation.createHTMLDocument('');\n    var closedShadowRootRegistry = new WeakMap();\n    var _DOMException = typeof DOMException === 'object' ? Error : DOMException;\n    var defineProperty = Object.defineProperty;\n    var forEach = Array.prototype.forEach;\n\n    var importPattern = /@import.+?;?$/gm;\n    function rejectImports(contents) {\n        var _contents = contents.replace(importPattern, '');\n        if (_contents !== contents) {\n            console.warn('@import rules are not allowed here. See https://github.com/WICG/construct-stylesheets/issues/119#issuecomment-588352418');\n        }\n        return _contents.trim();\n    }\n    function isElementConnected(element) {\n        return 'isConnected' in element\n            ? element.isConnected\n            : document.contains(element);\n    }\n    function unique(arr) {\n        return arr.filter(function (value, index) { return arr.indexOf(value) === index; });\n    }\n    function diff(arr1, arr2) {\n        return arr1.filter(function (value) { return arr2.indexOf(value) === -1; });\n    }\n    function removeNode(node) {\n        node.parentNode.removeChild(node);\n    }\n    function getShadowRoot(element) {\n        return element.shadowRoot || closedShadowRootRegistry.get(element);\n    }\n\n    var cssStyleSheetMethods = [\n        'addRule',\n        'deleteRule',\n        'insertRule',\n        'removeRule',\n    ];\n    var NonConstructedStyleSheet = CSSStyleSheet;\n    var nonConstructedProto = NonConstructedStyleSheet.prototype;\n    nonConstructedProto.replace = function () {\n        return Promise.reject(new _DOMException(\"Can't call replace on non-constructed CSSStyleSheets.\"));\n    };\n    nonConstructedProto.replaceSync = function () {\n        throw new _DOMException(\"Failed to execute 'replaceSync' on 'CSSStyleSheet': Can't call replaceSync on non-constructed CSSStyleSheets.\");\n    };\n    function isCSSStyleSheetInstance(instance) {\n        return typeof instance === 'object'\n            ? proto$1.isPrototypeOf(instance) ||\n                nonConstructedProto.isPrototypeOf(instance)\n            : false;\n    }\n    function isNonConstructedStyleSheetInstance(instance) {\n        return typeof instance === 'object'\n            ? nonConstructedProto.isPrototypeOf(instance)\n            : false;\n    }\n    var $basicStyleElement = new WeakMap();\n    var $locations = new WeakMap();\n    var $adoptersByLocation = new WeakMap();\n    var $appliedMethods = new WeakMap();\n    function addAdopterLocation(sheet, location) {\n        var adopter = document.createElement('style');\n        $adoptersByLocation.get(sheet).set(location, adopter);\n        $locations.get(sheet).push(location);\n        return adopter;\n    }\n    function getAdopterByLocation(sheet, location) {\n        return $adoptersByLocation.get(sheet).get(location);\n    }\n    function removeAdopterLocation(sheet, location) {\n        $adoptersByLocation.get(sheet).delete(location);\n        $locations.set(sheet, $locations.get(sheet).filter(function (_location) { return _location !== location; }));\n    }\n    function restyleAdopter(sheet, adopter) {\n        requestAnimationFrame(function () {\n            adopter.textContent = $basicStyleElement.get(sheet).textContent;\n            $appliedMethods\n                .get(sheet)\n                .forEach(function (command) {\n                return adopter.sheet[command.method].apply(adopter.sheet, command.args);\n            });\n        });\n    }\n    function checkInvocationCorrectness(self) {\n        if (!$basicStyleElement.has(self)) {\n            throw new TypeError('Illegal invocation');\n        }\n    }\n    function ConstructedStyleSheet() {\n        var self = this;\n        var style = document.createElement('style');\n        bootstrapper.body.appendChild(style);\n        $basicStyleElement.set(self, style);\n        $locations.set(self, []);\n        $adoptersByLocation.set(self, new WeakMap());\n        $appliedMethods.set(self, []);\n    }\n    var proto$1 = ConstructedStyleSheet.prototype;\n    proto$1.replace = function replace(contents) {\n        try {\n            this.replaceSync(contents);\n            return Promise.resolve(this);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    };\n    proto$1.replaceSync = function replaceSync(contents) {\n        checkInvocationCorrectness(this);\n        if (typeof contents === 'string') {\n            var self_1 = this;\n            $basicStyleElement.get(self_1).textContent = rejectImports(contents);\n            $appliedMethods.set(self_1, []);\n            $locations.get(self_1).forEach(function (location) {\n                if (location.isConnected()) {\n                    restyleAdopter(self_1, getAdopterByLocation(self_1, location));\n                }\n            });\n        }\n    };\n    defineProperty(proto$1, 'cssRules', {\n        configurable: true,\n        enumerable: true,\n        get: function cssRules() {\n            checkInvocationCorrectness(this);\n            return $basicStyleElement.get(this).sheet.cssRules;\n        },\n    });\n    cssStyleSheetMethods.forEach(function (method) {\n        proto$1[method] = function () {\n            var self = this;\n            checkInvocationCorrectness(self);\n            var args = arguments;\n            $appliedMethods.get(self).push({ method: method, args: args });\n            $locations.get(self).forEach(function (location) {\n                if (location.isConnected()) {\n                    var sheet = getAdopterByLocation(self, location).sheet;\n                    sheet[method].apply(sheet, args);\n                }\n            });\n            var basicSheet = $basicStyleElement.get(self).sheet;\n            return basicSheet[method].apply(basicSheet, args);\n        };\n    });\n    defineProperty(ConstructedStyleSheet, Symbol.hasInstance, {\n        configurable: true,\n        value: isCSSStyleSheetInstance,\n    });\n\n    var defaultObserverOptions = {\n        childList: true,\n        subtree: true,\n    };\n    var locations = new WeakMap();\n    function getAssociatedLocation(element) {\n        var location = locations.get(element);\n        if (!location) {\n            location = new Location(element);\n            locations.set(element, location);\n        }\n        return location;\n    }\n    function attachAdoptedStyleSheetProperty(constructor) {\n        defineProperty(constructor.prototype, 'adoptedStyleSheets', {\n            configurable: true,\n            enumerable: true,\n            get: function () {\n                return getAssociatedLocation(this).sheets;\n            },\n            set: function (sheets) {\n                getAssociatedLocation(this).update(sheets);\n            },\n        });\n    }\n    function traverseWebComponents(node, callback) {\n        var iter = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT, function (foundNode) {\n            return getShadowRoot(foundNode)\n                ? NodeFilter.FILTER_ACCEPT\n                : NodeFilter.FILTER_REJECT;\n        },\n        null, false);\n        for (var next = void 0; (next = iter.nextNode());) {\n            callback(getShadowRoot(next));\n        }\n    }\n    var $element = new WeakMap();\n    var $uniqueSheets = new WeakMap();\n    var $observer = new WeakMap();\n    function isExistingAdopter(self, element) {\n        return (element instanceof HTMLStyleElement &&\n            $uniqueSheets.get(self).some(function (sheet) { return getAdopterByLocation(sheet, self); }));\n    }\n    function getAdopterContainer(self) {\n        var element = $element.get(self);\n        return element instanceof Document ? element.body : element;\n    }\n    function adopt(self) {\n        var styleList = document.createDocumentFragment();\n        var sheets = $uniqueSheets.get(self);\n        var observer = $observer.get(self);\n        var container = getAdopterContainer(self);\n        observer.disconnect();\n        sheets.forEach(function (sheet) {\n            styleList.appendChild(getAdopterByLocation(sheet, self) || addAdopterLocation(sheet, self));\n        });\n        container.insertBefore(styleList, null);\n        observer.observe(container, defaultObserverOptions);\n        sheets.forEach(function (sheet) {\n            restyleAdopter(sheet, getAdopterByLocation(sheet, self));\n        });\n    }\n    function Location(element) {\n        var self = this;\n        self.sheets = [];\n        $element.set(self, element);\n        $uniqueSheets.set(self, []);\n        $observer.set(self, new MutationObserver(function (mutations, observer) {\n            if (!document) {\n                observer.disconnect();\n                return;\n            }\n            mutations.forEach(function (mutation) {\n                if (!hasShadyCss) {\n                    forEach.call(mutation.addedNodes, function (node) {\n                        if (!(node instanceof Element)) {\n                            return;\n                        }\n                        traverseWebComponents(node, function (root) {\n                            getAssociatedLocation(root).connect();\n                        });\n                    });\n                }\n                forEach.call(mutation.removedNodes, function (node) {\n                    if (!(node instanceof Element)) {\n                        return;\n                    }\n                    if (isExistingAdopter(self, node)) {\n                        adopt(self);\n                    }\n                    if (!hasShadyCss) {\n                        traverseWebComponents(node, function (root) {\n                            getAssociatedLocation(root).disconnect();\n                        });\n                    }\n                });\n            });\n        }));\n    }\n    Location.prototype = {\n        isConnected: function () {\n            var element = $element.get(this);\n            return element instanceof Document\n                ? element.readyState !== 'loading'\n                : isElementConnected(element.host);\n        },\n        connect: function () {\n            var container = getAdopterContainer(this);\n            $observer.get(this).observe(container, defaultObserverOptions);\n            if ($uniqueSheets.get(this).length > 0) {\n                adopt(this);\n            }\n            traverseWebComponents(container, function (root) {\n                getAssociatedLocation(root).connect();\n            });\n        },\n        disconnect: function () {\n            $observer.get(this).disconnect();\n        },\n        update: function (sheets) {\n            var self = this;\n            var locationType = $element.get(self) === document ? 'Document' : 'ShadowRoot';\n            if (!Array.isArray(sheets)) {\n                throw new TypeError(\"Failed to set the 'adoptedStyleSheets' property on \" + locationType + \": Iterator getter is not callable.\");\n            }\n            if (!sheets.every(isCSSStyleSheetInstance)) {\n                throw new TypeError(\"Failed to set the 'adoptedStyleSheets' property on \" + locationType + \": Failed to convert value to 'CSSStyleSheet'\");\n            }\n            if (sheets.some(isNonConstructedStyleSheetInstance)) {\n                throw new TypeError(\"Failed to set the 'adoptedStyleSheets' property on \" + locationType + \": Can't adopt non-constructed stylesheets\");\n            }\n            self.sheets = sheets;\n            var oldUniqueSheets = $uniqueSheets.get(self);\n            var uniqueSheets = unique(sheets);\n            var removedSheets = diff(oldUniqueSheets, uniqueSheets);\n            removedSheets.forEach(function (sheet) {\n                removeNode(getAdopterByLocation(sheet, self));\n                removeAdopterLocation(sheet, self);\n            });\n            $uniqueSheets.set(self, uniqueSheets);\n            if (self.isConnected() && uniqueSheets.length > 0) {\n                adopt(self);\n            }\n        },\n    };\n\n    window.CSSStyleSheet = ConstructedStyleSheet;\n    attachAdoptedStyleSheetProperty(Document);\n    if ('ShadowRoot' in window) {\n        attachAdoptedStyleSheetProperty(ShadowRoot);\n        var proto = Element.prototype;\n        var attach_1 = proto.attachShadow;\n        proto.attachShadow = function attachShadow(init) {\n            var root = attach_1.call(this, init);\n            if (init.mode === 'closed') {\n                closedShadowRootRegistry.set(this, root);\n            }\n            return root;\n        };\n    }\n    var documentLocation = getAssociatedLocation(document);\n    if (documentLocation.isConnected()) {\n        documentLocation.connect();\n    }\n    else {\n        document.addEventListener('DOMContentLoaded', documentLocation.connect.bind(documentLocation));\n    }\n\n}());\n","function getGlobal() {\n  if (\n    typeof global !== 'object' ||\n    !global ||\n    global.Math !== Math ||\n    global.Array !== Array\n  ) {\n    return (\n      self ||\n      window ||\n      global ||\n      (function() {\n        return this\n      })()\n    )\n  }\n  return global\n}\n\n/** Global options\n *  @public\n *  @namespace options {Object}\n */\nexport default {\n  store: null,\n  root: getGlobal(),\n  mapping: {}\n}\n","export function o(obj) {\n  return JSON.stringify(obj)\n}\n","import { h, h as createElement } from './h'\nimport options from './options'\nimport WeElement from './we-element'\nimport { render } from './render'\nimport { define } from './define'\nimport { tag } from './tag'\nimport { cloneElement } from './clone-element'\nimport { getHost } from './get-host'\nimport { rpx } from './rpx'\nimport { classNames, extractClass } from './class'\nimport { o } from './o'\nimport { extend, get, set, bind, unbind } from './extend'\nimport { Fragment } from './util'\nimport 'construct-style-sheets-polyfill'\n\nh.f = Fragment\n\nfunction createRef() {\n  return {}\n}\n\nconst $ = {}\nconst Component = WeElement\nconst defineElement = define\nconst elements = options.mapping\n\nconst omi = {\n  tag,\n  WeElement,\n  Component,\n  render,\n  h,\n  createElement,\n  options,\n  define,\n  cloneElement,\n  getHost,\n  rpx,\n  defineElement,\n  classNames,\n  extractClass,\n  createRef,\n  o,\n  elements,\n  $,\n  extend,\n  get,\n  set,\n  bind,\n  unbind\n}\n\noptions.root.Omi = omi\noptions.root.omi = omi\noptions.root.Omi.version = '6.23.0'\n\nexport default omi\n\nexport {\n  tag,\n  WeElement,\n  Component,\n  render,\n  h,\n  createElement,\n  options,\n  define,\n  cloneElement,\n  getHost,\n  rpx,\n  defineElement,\n  classNames,\n  extractClass,\n  createRef,\n  o,\n  elements,\n  $,\n  extend,\n  get,\n  set,\n  bind,\n  unbind\n}\n"]}